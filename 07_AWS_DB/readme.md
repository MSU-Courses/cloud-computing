# Базы данных в облаке. AWS RDS и DynamoDB

## Вопросы для самопроверки

После изучения данной темы студент должен уметь ответить на следующие вопросы:

- Чем отличается база данных от хранилища данных, и в каких случаях используется каждый из них?
- Какие преимущества дает Amazon RDS по сравнению с установкой базы данных на EC2 инстанс?
- В чем заключается разница между реляционными и NoSQL базами данных, и когда следует выбирать DynamoDB вместо RDS?
- Как работают Partition Key и Sort Key в DynamoDB, и почему правильный выбор ключей критически важен для производительности?

## Введение

В современном мире приложения генерируют огромные объемы данных, которые нужно хранить и быстро обрабатывать. Простое хранение данных в виде файлов или на объектном хранилище (например, Amazon S3) не обеспечивает удобного доступа, поиска и одновременной работы множества пользователей.

### Базы данных и хранилища данных

Прежде чем переходить к облачным решениям, важно понять фундаментальное различие между базой данных и хранилищем данных.

_Хранилище данных (storage)_ - это система, предназначенная для долгосрочного хранения данных в их исходном виде. Хранилище работает с данными как с непрозрачными блоками или файлами. Примером может служить Amazon S3, где вы можете хранить файлы, изображения, видео, бэкапы. Хранилище не знает о структуре данных внутри файлов и не предоставляет возможностей для сложных запросов.

_База данных (database)_ - это структурированный набор данных, оптимизированный для эффективного поиска, анализа и манипулирования информацией. База данных включает в себя функциональность запросов через специальные языки (например, SQL), контроль доступа, транзакции и аналитические возможности, которых нет у простого хранилища.

Ключевые различия между _базой данных_ и _хранилищем данных_:

| Характеристика   | Хранилище данных                                                        | База данных                                  |
| ---------------- | ----------------------------------------------------------------------- | -------------------------------------------- |
| Структура данных | Не структурированы, файлы/объекты                                       | Структурированы, таблицы/индексы             |
| Методы доступа   | Хранилище доступно через операции чтения и записи по физическим адресам | Доступ через языки запросов (SQL, NoSQL)     |
| Время жизни      | Долгосрочное хранение файлов и объектов                                 | Данные могут быть временными или постоянными |

_Аналогия из реальной жизни_: хранилище - это склад с коробками, где вы можете положить что угодно, но чтобы найти нужную вещь, придется перебирать коробки. База данных - это библиотека с каталогом, где каждая книга имеет место и вы можете быстро найти нужную информацию по запросу.

### Облачные базы данных. Зачем переносить базы данных в облако?

Традиционно компании размещали базы данных на собственных серверах (on-premises). Это означало необходимость:

- Покупать и обслуживать физические серверы.
- Устанавливать и обновлять операционные системы.
- Устанавливать и патчить программное обеспечение баз данных.
- Самостоятельно настраивать репликацию и бэкапы.
- Обеспечивать высокую доступность и масштабирование.
- Следить за безопасностью и энергопотреблением серверов.

Все эти задачи требуют значительных ресурсов, времени и квалифицированного персонала. Поэтому многие компании переходят на использование _облачных баз данных_.

_Облачные базы данных_ – это базы данных, развернутые в облачной инфраструктуре, которые предлагают масштабируемость, высокую доступность и управляемость без необходимости самостоятельно поддерживать серверы.

Переход к облачным базам данных позволяет компаниям избавиться от управления физическими серверами, упростить резервное копирование, повысить надежность (например, за счет репликации на несколько дата-центров) и платить только за фактическое использование ресурсов. Кроме того, провайдеры облака (такие как AWS) берут на себя множество рутинных задач – от установки ПО до резервного копирования – позволяя разработчикам _сосредоточиться на логике приложения_, а не на инфраструктуре.

## Типы баз данных

Базы данных делятся на два основных типа: _реляционные_ и _нереляционные_ (NoSQL).

### Реляционные базы данных (RDBMS)

_Реляционные базы данных_ (Relational Databases или RDBMS) хранят данные в структурированных таблицах с предопределенными схемами. Это классический подход к организации данных, который существует уже несколько десятилетий [^1].

_Основные характеристики_:

- Данные организованы в таблицы с фиксированными столбцами и строками.
- Используется язык SQL (Structured Query Language) для запросов и управления данными.
- Поддерживаются _ACID_ свойства (Atomicity, Consistency, Isolation, Durability), что гарантирует надежность транзакций.
  - [Интересная статья про ACID](https://habr.com/ru/articles/555920/)
- Связи между таблицами реализуются через первичные и внешние ключи.
- Масштабирование происходит вертикально (_vertical scaling_), это значит, что для увеличения производительности нужно использовать более мощный сервер.

_Когда использовать реляционные базы данных_:

- Когда у вас структурированные данные с четкими связями между сущностями.
- Для приложений, где критически важна консистентность данных (банковские системы, бухгалтерия).
- Когда требуются сложные запросы с использованием JOIN операций.
- Данные имеют сложные взаимосвязи, которые лучше моделировать в табличной форме.
- Для транзакционных систем, требующих ACID гарантий.

_Примеры реляционных СУБД_: MySQL, PostgreSQL, Oracle, Microsoft SQL Server, MariaDB.

![Рисунок 1. Пример реляционной базы данных с таблицами и связями](../_images/07/01_RDBMS.png)

_Рисунок 1. Пример реляционной базы данных с таблицами и связями_

### Нереляционные базы данных (NoSQL)

_NoSQL (Not Only SQL)_ базы данных появились как ответ на ограничения реляционных баз данных при работе с большими объемами неструктурированных данных и необходимостью горизонтального масштабирования.

_Основные характеристики_:

- Гибкая схема данных (schema-less), позволяющая легко изменять структуру.
- Горизонтальное масштабирование (_horizontal scaling_), это значит, что можно добавлять новые серверы в кластер для увеличения производительности.
- Высокая производительность для операций чтения и записи.
- Поддержка различных моделей данных: документы, ключ-значение, колоночные, графовые. Например:
  - _Ключ-значение (Key-Value)_: данные хранятся в виде пар ключ-значение.
  - _Документные базы данных_: данные хранятся в формате документов (например, JSON).
- Следование принципам BASE (базовая доступность, мягкое состояние, итоговая согласованность) вместо ACID.
  - [В чем разница между базами данных ACID и BASE?](https://aws.amazon.com/ru/compare/the-difference-between-acid-and-base-database/)

_Когда использовать NoSQL базы данных:_

- Для работы с большими объемами неструктурированных или полуструктурированных данных.
- Когда требуется быстрое масштабирование приложения.
- Для real-time аналитики и обработки потоковых данных.
- В IoT приложениях, социальных сетях, системах управления контентом.

_Примеры NoSQL баз данных_: MongoDB, Cassandra, Redis, DynamoDB.

> Выбор между SQL и NoSQL не является вопросом "что лучше". Это вопрос "что подходит для конкретной задачи". Многие современные приложения используют оба подхода одновременно - это называется _polyglot persistence_ (многоязычное хранение данных).

## Продвинутые концепции баз данных

Прежде чем перейти к конкретным сервисам AWS, важно понять несколько ключевых концепций, которые используются в современных системах управления базами данных.

### Репликация

_Репликация (replication)_ - это процесс создания копий базы данных на разных серверах. _Реплики_ - это точные копии данных, которые помогают повысить доступность и производительность системы.

Существует несколько подходов к репликации:

- _Leader-Follower репликация (Master-Slave)_. Один сервер выступает в роли лидера (мастера), который _принимает все операции записи_. Остальные серверы - последователи (слейвы), которые получают изменения от лидера и могут обслуживать операции чтения. Этот подход повышает доступность системы - если один сервер выходит из строя, приложение может переключиться на другой.
- _Leader-Leader репликация_. Несколько серверов могут принимать операции записи одновременно. В этом случае необходимы механизмы разрешения конфликтов.

Репликация может быть синхронной или асинхронной:

- _Синхронная репликация_ гарантирует, что данные записаны на все реплики перед подтверждением операции. Это обеспечивает консистентность, но может снижать производительность.
- _Асинхронная репликация_ не ждет подтверждения от реплик, что быстрее, но создает риск потери данных при сбое.

Представим пример, у нас есть база данных с пользователями. Если у нас настроена репликация, то когда пользователь добавляется на главный сервер, эта информация автоматически копируется на все реплики. Если главный сервер выходит из строя, приложение может продолжать работать, обращаясь к одной из реплик.

### Read и Write Replicas

_Read Replicas_ - это специальные реплики базы данных, предназначенные только для чтения данных. Они используются для разгрузки основной базы данных от операций чтения. Основная база данных обрабатывает все операции записи и репликирует изменения на _read replicas_. Приложение может направлять запросы на чтение к любой из реплик, распределяя нагрузку.

_Write Replicas_ - реплики, которые также могут принимать операции записи. Используются в конфигурациях leader-leader репликации.

### Шардирование

_Шардирование (sharding)_ - это техника горизонтального разделения данных между несколькими серверами. Каждый сервер (shard) содержит часть общего набора данных.

| Преимущества шардирования                                                                                            | Недостатки шардирования                                              |
| -------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- |
| Позволяет распределить нагрузку между несколькими серверами.                                                         | Усложняется архитектура приложения.                                  |
| Каждый шард можно масштабировать независимо, это значит, что можно добавлять ресурсы только там, где это необходимо. | Запросы, требующие данных из нескольких шардов, становятся сложнее.  |
| Параллельная обработка запросов к разным шардам значительно ускоряет операции.                                       | Необходимо продумывать стратегию распределения данных между шардами. |

Шардирование бывает двух основных типов: _горизонтальное_ и _вертикальное_.

- _Горизонтальное шардирование_. Данные разделяются по строкам. _Например_, пользователи с ID от 1 до 1000 хранятся на одном шарде, от 1001 до 2000 - на другом. _На каждом сервере одинаковая структура таблиц, но разные данные_.
- _Вертикальное шардирование_. Данные разделяются по столбцам. Это полезно, если некоторые столбцы используются чаще, а другие реже. Например, в интернет-магазине один шард может содержать информацию о клиентах, а другой - о товарах.

_Пример горизонтального шардирования_:

У нас есть база данных с миллионами пользователей. Вместо того чтобы хранить всех пользователей на одном сервере, мы можем разделить их по регионам:

- _Shard 1_: пользователи из Европы
- _Shard 2_: пользователи из Америки
- _Shard 3_: пользователи из Азии

Когда пользователь из Европы заходит в систему, его данные обрабатываются на Shard 1, что снижает нагрузку на остальные шарды и улучшает производительность.

_Пример вертикального шардирования_:

Здесь таблица разделяется по столбцам. Например, есть следующие таблицы:

- _Клиенты (`customers`)_. Хранит идентификатор, имя, email, телефон, адрес. Очень часто используется для быстрого поиска и общения с клиентом.
- _Заказы (`orders`)_. Хранит информацию о заказах - id заказа, клиент id, дата заказа, список товаров, сумма.

В данном случае:

- _Шард 1_. Хранит таблицу `customers` с основной информацией о клиентах. Эта таблица используется часто для операций авторизации, связи с клиентом, маркетинга.

  | customer_id | username | email            | phone        |
  | ----------- | -------- | ---------------- | ------------ |
  | 101         | Anna     | anna@example.com | +373XXXXXXXX |
  | 102         | Bob      | bob@example.com  | +373XXXXXXXX |

- _Шард 2_. Хранит таблицу `orders` с заказами клиентов. Эта таблица часто очень большая, с большим количеством операций записи и чтения.

  | order_id | customer_id | order_date | items | total_amount |
  | -------- | ----------- | ---------- | ----- | ------------ |
  | 5001     | 101         | 2024-01-15 | [...] | 150.00       |
  | 5002     | 102         | 2024-01-16 | [...] | 200.00       |

Такое разделение позволяет независимо масштабировать шард с заказами (обычно он тяжелее), не перегружая сервер с клиентскими данными. При необходимости приложение обращается к двум серверам для получения полной информации, но благодаря разделению нагрузка распределяется и производительность улучшается.

Это классический пример вертикального шардирования с двумя шардами по _функциональному признаку_: клиентские данные и заказные данные хранятся отдельно для оптимизации и масштабирования.

> _Репликация и шардирование_ - это разные концепции. Репликация создает копии одних и тех же данных на разных серверах для повышения доступности. Шардирование разделяет разные данные между серверами для масштабирования.

## Базы данных в AWS

### Обзор сервисов баз данных в AWS

Amazon Web Services предоставляет несколько сервисов для работы с базами данных, каждый из которых оптимизирован под определенные задачи.

- Amazon RDS (Relational Database Service) - управляемый сервис для реляционных баз данных.
- Amazon DynamoDB - полностью управляемая NoSQL база данных типа ключ-значение и документная.
- Amazon Redshift - сервис хранилища данных (data warehouse) для аналитики больших объемов данных.

> Часто в одном проекте используются несколько типов баз данных. Например, RDS для основных транзакционных данных, DynamoDB для сессий пользователей, и Redshift для аналитики.

### Managed vs Unmanaged сервисы

В AWS существует два подхода к развертыванию баз данных:

_Unmanaged (неуправляемый подход)_. Вы можете установить базу данных на EC2 инстанс самостоятельно. В этом случае вы получаете полный контроль, но также полную ответственность за:

- Масштабирование ресурсов.
- Настройку отказоустойчивости.
- Обеспечение высокой доступности.
- Создание и управление бэкапами.
- Ограничения в масштабируемости.

_Managed (управляемый подход)_. Amazon RDS автоматизирует большинство рутинных задач:

- Автоматические бэкапы.
- Патчинг операционной системы и СУБД. Это значит, что AWS следит за обновлениями и устанавливает их без вашего участия.
- Настройка репликации и высокой доступности.
- Масштабирование ресурсов.
- Мониторинг и оповещения.

## Amazon RDS

### Что такое Amazon RDS?

_Amazon RDS (Relational Database Service)_ – это облачный, _управляемый сервис_, предоставляющий управляемые реляционные базы данных. Проще говоря, RDS позволяет развернуть привычную СУБД в облаке AWS без необходимости вручную устанавливать СУБД на сервере.

Так как сервис управляемый, AWS берет на себя множество задач администрирования:

- выделение и настройку серверного инстанса,
- установку и патчи СУБД,
- автоматические бэкапы,
- масштабирование ресурсов,
- мониторинг системы.

Благодаря этому разработчики могут создать новую базу данных за считанные минуты и сразу приступать к работе с данными, не заботясь о инфраструктуре. Amazon RDS поддерживает несколько движков баз данных (включая открытые и коммерческие), давая гибкость выбора подходящей СУБД под ваши нужды. Фактически, RDS – это _Database-as-a-Service_: вы управляете базой через консоль AWS или API, а «под капотом» сервис сам запускает экземпляры баз данных на серверах EC2 и обслуживает их.

### Зачем использовать RDS вместо установки БД на EC2

Как было сказано ранее, Amazon RDS является _управляемым сервисом_, что решает множество задач, связанных с администрированием баз данных, которые при использовании EC2 ложатся на плечи разработчиков и администраторов. Почему же _предпочтительнее воспользоваться Amazon RDS?_

- _Меньше администрирования_. RDS автоматизирует рутинные задачи, такие как установка СУБД, применение обновлений, резервное копирование и восстановление. Нет необходимости вручную настраивать ОС и ПО.
- _Автоматическое резервное копирование_. Сервис RDS регулярно делает резервные копии базы и хранит их, позволяя настроить точку восстановления во времени (Point-In-Time Recovery).
- _Масштабирование и производительность_. Вы можете одним действием повысить мощность (например, перейти на более крупный размер инстанса с большим количеством CPU/RAM) или увеличить объем хранилища.
- _Высокая доступность_. RDS поддерживает развертывание базы данных в режиме Multi-AZ (несколько зон доступности) – при этом автоматически содержится резервная копия базы на другой физической площадке, которая при сбое основной принимает нагрузку без вмешательства пользователя.
- _Легкость миграции_. AWS предоставляет инструменты, такие как AWS Database Migration Service (DMS), позволяющие с минимальным простоем перенести данные из локальной базы или из другого провайдера в RDS [^4].

Проще говоря, RDS избавляет от «головной боли» по управлению сервером базы данных. Вы получаете готовый кластер с нужной вам СУБД, а обновление версий, исправление уязвимостей, замена вышедшего из строя оборудования – всем этим занимается AWS. В результате команда может сосредоточиться на данных и приложении, а не на поддержании работоспособности СУБД.

### Основные компоненты Amazon RDS

#### Экземпляр базы данных (RDS Instance)

_RDS Instance_ - это изолированная среда базы данных в облаке AWS. Это базовый строительный блок Amazon RDS, который _представляет собой виртуальный сервер базы данных_.

Каждый RDS инстанс может содержать одну или несколько баз данных, созданных пользователем. Вы можете получить доступ к инстансу теми же инструментами и приложениями, что и к обычной базе данных.

#### Поддерживаемые движки баз данных

Amazon RDS поддерживает 7 различных движков баз данных:

- _MySQL_ - популярная open-source СУБД.
- _PostgreSQL_ - мощная open-source объектно-реляционная СУБД.
- _MariaDB_ - форк MySQL с дополнительными возможностями.
- _Oracle_ - коммерческая СУБД корпоративного уровня.
- _Microsoft SQL Server_ - СУБД от Microsoft.
- _Amazon Aurora_ - совместимый с MySQL и PostgreSQL.
- _IBM Db2_ - коммерческая СУБД от IBM.

Каждый движок имеет свои особенности и используется в зависимости от требований проекта и существующей экосистемы.

#### Типы RDS инстансов

Amazon RDS предлагает различные классы инстансов, оптимизированные под разные рабочие нагрузки.

- _Standard Performance (db.m классы)_. Инстансы общего назначения, предлагающие сбалансированное соотношение CPU, памяти и сетевых ресурсов. Подходят для большинства приложений с умеренной нагрузкой.
- _Memory Optimized (db.r, db.x, db.z классы)_. Инстансы, оптимизированные для задач, требующих большого объема оперативной памяти. Используются для высокопроизводительных баз данных и аналитики больших данных в памяти.
- _Burstable Performance (db.t классы)_. Инстансы с возможностью кратковременного увеличения производительности. Идеальны для рабочих нагрузок с непредсказуемыми всплесками активности. Накапливают CPU кредиты во время простоя, которые можно использовать при повышенной нагрузке.

Каждый класс инстанса включает тип и размер. Например, `db.t3.medium` - это инстанс класса _Burstable Performance_, типа `t3`, размера `medium`.

#### Хранение данных в RDS

RDS предлагает несколько типов хранилища:

- _General Purpose SSD (gp2, gp3)_. Сбалансированное соотношение цены и производительности. Подходит для большинства рабочих нагрузок.
- _Provisioned IOPS SSD (io1, io2)_. Высокопроизводительное хранилище для I/O интенсивных рабочих нагрузок. Гарантирует определенное количество операций ввода-вывода в секунду.
- _Magnetic (стандартное)_. Более дешевый вариант, но с низкой производительностью. Рекомендуется только для архивных данных или тестовых сред.

Хранилище автоматически масштабируется по мере необходимости. Можно начать, например, с _20 ГБ_ и настроить автоматическое масштабирование хранилища, чтобы оно увеличивалось по мере заполнения (до заданного предела).

#### RDS в VPC и Private Subnets

Amazon RDS инстансы развертываются внутри _Virtual Private Cloud (VPC)_, что обеспечивает изоляцию и безопасность. Рекомендуется размещать RDS инстансы в _private subnets_ (приватных подсетях), чтобы ограничить доступ к базе данных из интернета.

Например, ваше приложение на EC2 инстансе в _public subnet_ может обращаться к RDS инстансу в _private subnet_, но внешние пользователи не смогут напрямую подключиться к базе данных.

![Рисунок 2. Архитектура системы с EC2 в публичной подсети и RDS в приватной подсети](../_images/07/02_RDS_Architecture.png)

_Рисунок 2. Архитектура системы с EC2 в публичной подсети и RDS в приватной подсети_

#### Subnet Groups

_Subnet Group_ - это ресурс AWS, определяющий какие подсети VPC доступны для размещения инстансов RDS.

При создании RDS вы указываете VPC и subnet group – RDS выберет одну из указанных приватных подсетей для основного инстанса и другую (в другом AZ) для резервного, _если включен Multi-AZ_ (об этом далее).

Subnet Group нужна, чтобы база могла работать в многозоновой конфигурации и быть изолированной в приватных сетях.

_Процесс создания Subnet Group_:

1. Создайте VPC с необходимым диапазоном IP адресов.
2. Создайте минимум две подсети в разных Availability Zones.
3. Создайте Subnet Group, добавив в нее эти подсети.
4. При создании RDS инстанса выберите эту группу.

> Для Multi-AZ развертывания Subnet Group должна содержать подсети минимум в двух разных Availability Zones. Это критически важно для обеспечения высокой доступности.

#### Parameter Group и Option Group

_Parameter Group_ и _Option Group_ - это набор настраиваемых параметров для конкретного движка базы данных в RDS. Каждый движок имеет свои параметры, которые можно изменить для оптимизации производительности, безопасности и поведения базы данных. Например, можно настроить размер пула соединений, время ожидания запросов, параметры кэширования и т.д.

### Репликация и высокая доступность в RDS

Для обеспечения надежности и масштабируемости RDS предлагает _два основных механизма репликации_: Multi-AZ и Read Replicas.

_Multi-AZ (Multi-Availability Zone)_ - это конфигурация RDS для обеспечения высокой доступности и минимизации времени простоя [^5].

Как это работает:

- RDS автоматически создает _синхронную_ резервную копию (standby replica) в другой Availability Zone внутри того же региона.
- Основной инстанс обрабатывает операции чтения и записи.
- Все изменения синхронно реплицируются на резервный инстанс.
- В случае сбоя основного инстанса RDS автоматически переключается на резервный (failover).

![Рисунок 3. Multi-AZ развертывание RDS с основным и резервным инстансами в разных зонах доступности](../_images/07/03_multi_az_replication_01.png)

_Рисунок 3. Multi-AZ развертывание RDS с основным и резервным инстансами в разных зонах доступности_

![Рисунок 4. Процесс автоматического переключения на резервный инстанс при сбое основного](../_images/07/04_multi_az_replication_02.png)

_Рисунок 4. Процесс автоматического переключения на резервный инстанс при сбое основного_

> Multi-AZ не является решением для масштабирования операций чтения. Standby реплика не обслуживает запросы чтения, а только готовится к переключению в случае сбоя. Для масштабирования чтения используются Read Replicas.

_Read Replicas_ - это асинхронно реплицируемые копии базы данных, предназначенные для обслуживания операций чтения.

_Ключевые особенности_:

- Асинхронная репликация означает, что изменения реплицируются с небольшой задержкой.
- Можно создать до 15 read replicas для одного RDS инстанса.
- Read replicas могут находиться в том же регионе или в других регионах AWS.
- При необходимости read replica может быть повышена до статуса _master_ базы данных.

_Использование Read Replicas_:

- Разгрузка основной базы данных от операций чтения.
- Аналитические запросы можно направлять на read replica, не влияя на производительность основной БД.
- Географически распределенные приложения могут использовать локальные read replicas для снижения задержек.

![Рисунок 5. Пример использования Read Replicas для масштабирования операций чтения](../_images/07/05_schema_read_replica.png)

_Рисунок 5. Пример использования Read Replicas для масштабирования операций чтения_

Используя комбинацию _Multi-AZ_ и _Read Replicas_, можно достичь и высокой доступности, и масштабирования на чтение. Например, базу в продакшене часто делают Multi-AZ для надежности, а для высоконагруженных систем добавляют несколько реплик чтения за балансировщиком запросов, чтобы множество пользователей могли параллельно выполнять запросы без нагрузки на основную базу.

### Автоматические бэкапы в RDS

Одним из главных преимуществ RDS является автоматизация процесса бэкапов.

_Ключевые особенности_:

- RDS автоматически создает бэкапы вашей базы данных в указанное окно времени.
- Бэкапы сохраняются в Amazon S3 и автоматически реплицируются для надежности.
- Вы можете настроить период хранения бэкапов от 1 до 35 дней.
- Point-in-time восстановление позволяет восстановить базу данных на любую секунду в пределах периода хранения.

_Типы бэкапов_:

- Автоматические бэкапы - создаются по расписанию.
- Ручные снимки (_manual snapshots_) - создаются пользователем и хранятся до явного удаления.

> _Важно_. Автоматические бэкапы включены по умолчанию и не требуют дополнительной настройки. Вам не нужно самостоятельно писать скрипты для бэкапов.

### Сценарии использования RDS

Когда _следует использовать_ Amazon RDS:

- _Когда вам нужна реляционная база данных для приложения_ (например, веб-сайт с пользователями, заказы, платежи) и вы хотите упростить ее обслуживание.
- _Необходима средняя или высокая частота запросов_ на чтение и запись (до 30,000 IOPS).
- Критически _важна долговечность данных_ и ACID гарантии.
- _При миграции существующей базы в облако_: если у вас уже есть PostgreSQL/MySQL/Oracle и т.д. локально, вы можете относительно безболезненно перенести их в RDS, не переписывая само приложение

Когда _НЕ следует_ использовать Amazon RDS:

- _Очень высокие требования к производительности_ записи или масштабирования. RDS вертикально масштабируется до определенного лимита (например, 64 vCPU, 256GB RAM, ~16-64 ТБ хранилища в зависимости от движка). Если нужно обрабатывать сотни миллионов транзакций в секунду по всей планете, реляционная БД может стать узким местом.
- _Неструктурированные или быстро меняющиеся данные_. Когда схема данных не фиксирована или требует хранения огромных JSON-документов, графов – может быть разумнее использовать соответствующую NoSQL базу
- Приложение выполняет простые GET или PUT запросы, которые может обработать NoSQL база.
- Требуется глубокая кастомизация СУБД на уровне операционной системы.

### Billing в RDS

Amazon RDS использует модель оплаты за использование. За что вы платите:

- _Тип и размер инстанса_ (instance type and size). Стоимость зависит от класса инстанса (db.t3, db.r5 и т.д.) и его размера (small, medium, large).
- _Движок базы данных_ (database engine). Коммерческие движки (Oracle, SQL Server) стоят дороже, чем open-source (MySQL, PostgreSQL).
- _Класс памяти_ (memory class). Инстансы с большим объемом памяти стоят дороже.
- _Хранилище (storage)_. Вы платите за выделенное хранилище по тарифу _GB/месяц_.
- _Бэкапы (backups)_. Бэкапы в объеме до 100% от размера базы данных предоставляются бесплатно. За дополнительное место для бэкапов взимается плата.
- _Передача данных_. Трафик между RDS и EC2 внутри одного региона обычно бесплатен (если они в одной зоне или через межAZ – может тарифицироваться меж-AZ трафик).

Существуют две модели покупки:

- _On-Demand Instances_. Вы платите за вычислительную мощность по часам, без долгосрочных обязательств. Подходит для непредсказуемых рабочих нагрузок.
- _Reserved Instances_. Вы резервируете инстанс на срок 1 или 3 года с единовременным платежом. Это значительно дешевле (до 60-70% экономии), но требует долгосрочного обязательства.

## Amazon Aurora

### Что такое Amazon Aurora?

_Amazon Aurora_ - это один из движков, доступных в Amazon RDS, но с существенными отличиями от классических движков [^7].

Aurora представляет собой _полностью управляемую реляционную базу данных, совместимую с MySQL и PostgreSQL_. Это означает, что код, инструменты и приложения, которые работают с MySQL или PostgreSQL, будут работать и с Aurora без изменений или с минимальными изменениями.

### Особенности Amazon Aurora

_Ключевые особенности Aurora_ [^7]:

- До 5 раз выше производительность по сравнению с обычным MySQL.
- До 3 раз выше производительность по сравнению с обычным PostgreSQL.
- Высокая доступность - до 99.99% в одном регионе и 99.999% в мультирегиональной конфигурации.
- Автоматическое масштабирование хранилища до 128 TiB. В то время как в стандартном RDS MySQL/PostgreSQL максимальный размер хранилища ограничен 64 TiB.
- Aurora может автоматически создавать до 15 реплик чтения с низкой задержкой, в то время как стандартный RDS MySQL поддерживает до 5 реплик.
- Фактически, _Aurora изначально Multi-AZ по дизайну_ - хранение распределено, и сбой сразу нескольких копий маловероятен.

_Aurora_ - это _fully managed service_, что означает автоматизацию трудоемких задач:

- Автоматическое создание резервных копий (backups) в S3.
- Репликация данных через несколько Availability Zones автоматически.
- Автоматическое масштабирование (scaling) хранилища и вычислительных ресурсов.

Механизмы _failure detection_ и _repair_:

- Aurora постоянно мониторит состояние дисков и сегментов данных.
- При обнаружении сбоя автоматически заменяет поврежденные сегменты.
- Восстановление после сбоя происходит мгновенно (instant crash recovery) - не требуется воспроизведение журнала транзакций.

> Aurora отличается от традиционных баз данных тем, что отделяет уровень хранения от уровня вычислений. Это позволяет масштабировать их независимо друг от друга.

## Amazon DynamoDB

### Что такое Amazon DynamoDB?

_Amazon DynamoDB_ - это _полностью управляемая (fully managed) NoSQL база данных_, предоставляющая быструю и предсказуемую производительность при любом масштабе.

_Основные характеристики_:

- Тип базы данных: key-value и документная модель.
- Serverless - не требует управления серверами.
- Автоматическое масштабирование в зависимости от нагрузки.
- Репликация данных через несколько Availability Zones автоматически.
- Низкая задержка запросов - _миллисекунды_.

DynamoDB предназначена для приложений, которым нужна очень быстрая запись и чтение данных в любом масштабе – от сотен запросов в секунду до миллионов, – без забот о настройке кластера. AWS обеспечивает под капотом распределение данных по множеству узлов, репликацию и другие сложности, предоставляя разработчику простой интерфейс: таблицы, элементы, атрибуты.

### Что такое NoSQL в контексте DynamoDB

_NoSQL – "Not Only SQL"_ – подразумевает, что база не ограничена табличной структурой и SQL-запросами.

DynamoDB использует _ключ-значение_ и _документную_ модели данных:

- _Key-Value модель_. Данные хранятся как пары ключ-значение. Очень быстрый доступ к данным по ключу.
- _Document модель_. Позволяет хранить сложные вложенные структуры данных в форматах JSON, BSON или XML.

Это значит, что в DynamoDB нет фиксированной схемы, как в SQL – вы можете добавить в один элемент новые атрибуты, и это не затронет другие элементы. Например, в одной записи может быть поле "age", а в другой его нет. DynamoDB жертвует возможностью сложных запросов (например, нет JOIN, агрегаций по нескольким таблицам) ради скорости и простоты масштабирования.

В DynamoDB _данные распределяются по многим внутренним узлам (shards) автоматически_, поэтому нагрузка масштабируется горизонтально почти безгранично. Такая архитектура идеально подходит для случаев, когда нужно хранить большие объемы простых данных и быстро их извлекать по ключу. _Например_: хранилище сессий пользователей, профили пользователей, кеш результатов, журнал событий IoT-датчиков, список товаров в каталоге – все это примеры, где DynamoDB успешно применяется.

### Основные понятия DynamoDB

В DynamoDB есть 3 основных понятия:

- _Table (таблица)_ - это коллекция данных. Аналог таблицы в реляционных БД, но без жесткой схемы.
- _Item (элемент)_ - это отдельная запись в таблице. Аналог строки в реляционной БД. Каждый элемент имеет уникальный _Primary Key (первичный ключ)_, который однозначно его идентифицирует.
- _Attribute (атрибут)_ - это часть данных в элементе. Аналог столбца, но разные элементы могут иметь разные атрибуты.

_Primary Key_ в DynamoDB уникально идентифицирует каждый элемент в таблице. DynamoDB поддерживает два типа первичных ключей:

- _Partition Key_
- _Sort Key_

Вы можете использовать либо одинарный ключ (только _Partition Key_), либо составной ключ (_Partition Key + Sort Key_). Нельзя использовать два _Partition Key_ в одной таблице.

_Partition Key_ (простой первичный ключ):

- Состоит из одного атрибута.
- DynamoDB использует значение partition key как вход для внутренней хэш-функции.
- Результат хэш-функции определяет партицию (физическое хранилище), где будет храниться элемент.
- Никакие два элемента в таблице не могут иметь одинаковое значение partition key.

_Composite Primary Key_ - _Partition Key_ + _Sort Key_:

- Состоит из двух атрибутов: `partition key` и `sort key`.
- DynamoDB использует partition key для определения партиции, как и раньше.
- Все элементы с одинаковым partition key хранятся вместе, отсортированные по sort key.
- В таблице могут быть элементы с одинаковым partition key, но у них должны быть разные sort keys.

_Partition Key используется для распределения данных_:

- DynamoDB применяет хэш-функцию к значению partition key.
- Результат хэш-функции определяет партицию, где физически будут храниться данные.
- Это обеспечивает равномерное распределение нагрузки между партициями.

Важно выбирать partition key так, чтобы данные распределялись равномерно. Плохой выбор может привести к "горячим партициям" (hot partitions), где одна партиция получает непропорционально большую нагрузку.

_Sort Key используется для сортировки и запросов:_

- Элементы с одинаковым partition key хранятся вместе, отсортированные по sort key.
- Это позволяет эффективно запрашивать диапазоны данных.
- Sort key также может использоваться для моделирования связей между данными. То есть, вы можете хранить связанные элементы вместе, используя один и тот же partition key и разные sort keys.

![Рисунок 6. Пример таблиц DynamoDB с Single и Composite Primary Keys](../_images/07/06_dynamodb_keys.png)

_Пример_:

- Таблица `Orders` с composite primary key:

  - _Partition Key_: `CustomerID` - этот ключ определяет, к какому клиенту относится заказ.
  - _Sort Key_: `OrderDate` - этот ключ сортирует заказы клиента по дате.

Такая структура позволяет легко запрашивать все заказы конкретного клиента, а также получать их в хронологическом порядке.

_Когда использовать Partition Key vs Composite Key_:

- Используйте простой Partition Key, когда каждый элемент уникален и вам не нужны запросы по диапазонам.
- Используйте Composite Key, когда нужно группировать связанные элементы и запрашивать их наборами.

> Правильный выбор Partition Key критически важен для производительности DynamoDB. Плохой выбор может привести к неравномерному распределению нагрузки и снижению производительности.

### Формат данных для загрузки в DynamoDB в виде JSON

При добавлении элемента в таблицу данные можно передать в формате JSON. Каждый атрибут элемента должен быть представлен в виде объекта, где ключ - это имя атрибута, а значение - это объект с типом и значением.

```json
{
  "AttributeName1": { "Type": "Value" },
  "AttributeName2": { "Type": "Value" }
}
```

_Типы данных_:

- `S` - строка (String)
- `N` - число (Number) (числа указываются в кавычках)
- `B` - бинарные данные (Binary)
- `SS` - множество строк (String Set)
- `NS` - множество чисел (Number Set)
- `BS` - множество бинарных данных (Binary Set)
- `BOOL` - булевый тип (true/false)
- `NULL` - null

_Пример простой записи:_

```json
{
  "UserID": { "S": "user123" },
  "Name": { "S": "Иван Иванов" },
  "Age": { "N": "30" },
  "IsPremium": { "BOOL": true },
  "JoinDate": { "S": "2025-10-22" }
}
```

_Пример записи с множествами:_

```json
{
  "ProductID": { "S": "prod456" },
  "Categories": { "SS": ["Техника", "Электроника"] },
  "Price": { "N": "199.99" },
  "Tags": { "SS": ["новинка", "скидка"] },
  "Availability": { "BOOL": true }
}
```

### Операции Scan и Query в DynamoDB

DynamoDB предоставляет две операции для получения данных: _Scan_ и _Query_.

_Query_ - это операция прямого поиска по первичному ключу:

- Выполняет прямой поиск в выбранной партиции.
- Требует указания partition key в условии.
- Опционально может использовать операторы сравнения на sort key (`=`, `<`, `>`, `BETWEEN`, `BEGINS_WITH`).
- Очень быстрая операция - обычно завершается за 100 миллисекунд или меньше.

_Scan_ - это операция сканирования всей таблицы:

- Проверяет каждый элемент в таблице или индексе.
- Не требует указания ключа.
- Может занимать несколько часов на больших таблицах.
- Максимальный размер результата - 1 MB данных.

_Когда использовать Query vs Scan_:

- Всегда используйте _Query_, когда это возможно.
- Используйте _Scan_ только когда вам действительно нужны все данные из таблицы.
- Если вам часто нужны запросы по атрибутам, не являющимся ключами, рассмотрите создание _Global Secondary Index_.

> Операция Scan на большой таблице может быть очень дорогой и медленной. Старайтесь проектировать схему данных так, чтобы использовать Query вместо Scan.

### Использование AWS CLI для работы с DynamoDB

Общий синтаксис команды AWS CLI для DynamoDB:

```bash
aws dynamodb <operation> --table-name <table_name> [options]
```

_Список некоторых распространенных операций:_

- `list-tables` - получить список всех таблиц:

  ```bash
  aws dynamodb list-tables
  ```

- `describe-table` - получить информацию о таблице:

  ```bash
  aws dynamodb describe-table --table-name MyTable
  ```

- `get-item` - получить элемент по ключу:

  ```bash
  aws dynamodb get-item \
  --table-name Users \
  --key '{"UserID": {"S": "user123"}}'
  ```

- `put-item` - добавить или заменить элемент:

  ```bash
    aws dynamodb put-item \
    --table-name Users \
    --item '{
      "UserID": {"S": "user123"},
      "Name": {"S": "Иван Иванов"},
      "Age": {"N": "30"},
      "IsPremium": {"BOOL": true},
      "JoinDate": {"S": "2025-10-21"}
    }'
  ```

- `update-item` - обновить атрибуты элемента:

  ```bash
  aws dynamodb update-item \
    --table-name Users \ # имя таблицы
    --key '{"UserID": {"S": "user123"}}' \ # ключ элемента
    --update-expression "SET Age = :newAge" \ # выражение обновления
    --expression-attribute-values '{":newAge": {"N": "31"}}' # значения для выражения
  ```

- `batch-write-item` - записать несколько элементов в таблицу:

  ```bash
  aws dynamodb batch-write-item --table-name Users --request-items file://users.json
  ```

  - Флаг `--request-items file://items.json` позволяет указать файл с данными для записи. Формат файла:

  ```json
  {
    "Users": [
      {
        "PutRequest": {
          "Item": {
            "UserID": { "S": "user124" },
            "Name": { "S": "James Smith" },
            "DateJoined": { "S": "2025-10-20" }
          }
        }
      },
      {
        "PutRequest": {
          "Item": {
            "UserID": { "S": "user125" },
            "Name": { "S": "Maria Garcia" },
            "DateJoined": { "S": "2025-10-19" }
          }
        }
      },
      {
        "DeleteRequest": {
          "Key": {
            "UserID": { "S": "user126" }
          }
        }
      }
    ]
  }
  ```

  В параметре `--request-items` операции для каждого элемента _могут быть только двух типов_:

  - `PutRequest` - вставка или обновление элемента (Item) в таблицу.
  - `DeleteRequest` - удаление элемента по ключу из таблицы.

- `query` - выполнить запрос по ключу:

  ```bash
  aws dynamodb query \
    --table-name Messages \ # имя таблицы
    --key-condition-expression "ChatRoomID = :roomid AND Timestamp > :time" \ # условие по ключу
    --expression-attribute-values '{":roomid":{"S":"room1"}, ":time":{"N":"1600000000"}}' \ # значения для условия
    --limit 20 # ограничение на 20 результатов
  ```

- `scan` - выполнить сканирование таблицы:

  ```bash
  aws dynamodb scan \
    --table-name Users \ # имя таблицы
    --filter-expression "Age > :age" \ # фильтр по атрибуту Age
    --expression-attribute-values '{":age":{"N":"25"}}' \ # значения для фильтра
    --limit 10 # ограничение на 10 результатов
  ```

### Использование AWS SDK для работы с DynamoDB

Чаще всего для работы с DynamoDB используется AWS SDK, который доступен для множества языков программирования (JavaScript, Python, Java, C#, Go и др.). Например, для JavaScript (Node.js) используется пакет `@aws-sdk/client-dynamodb`.

_Пример 1. Подключение к DynamoDB и добавление элемента:_

```javascript
import {
  DynamoDBClient,
  PutItemCommand,
  GetItemCommand,
} from "@aws-sdk/client-dynamodb";

const client = new DynamoDBClient({ region: "us-east-1" });

// Добавляем элемент
const putCommand = new PutItemCommand({
  TableName: "Users",
  Item: {
    UserID: { S: "user123" },
    Name: { S: "Иван Иванов" },
    Age: { N: "30" },
    Premium: { BOOL: true },
  },
});

await client.send(putCommand);

// Читаем элемент по ключу
const getCommand = new GetItemCommand({
  TableName: "Users",
  Key: { UserID: { S: "user123" } },
});

const response = await client.send(getCommand);
console.log(response.Item);
```

### Сценарии использования DynamoDB

Когда _следует использовать_ Amazon DynamoDB:

- Приложения с непредсказуемой нагрузкой, требующие автоматического масштабирования.
- Когда нужна очень низкая задержка (миллисекунды).
- Мобильные приложения с офлайн синхронизацией.

Когда _НЕ следует_ использовать DynamoDB:

- Когда требуются сложные JOIN операции между таблицами.
- Для OLAP (Online Analytical Processing) и сложной аналитики.
- Когда критически важна немедленная консистентность (DynamoDB использует eventual consistency по умолчанию).
- Для приложений с редкими, но очень сложными запросами.

## Amazon Redshift

### Что такое Amazon Redshift?

_Amazon Redshift_ - это быстрый, полностью управляемый сервис хранилища данных (data warehouse), позволяющий анализировать данные с использованием SQL и инструментов бизнес-аналитики.

_Ключевые особенности_:

- Колоночное хранение данных - данные организованы по столбцам, а не по строкам.
- Массивно-параллельная обработка (_Massively Parallel Processing_, _MPP_) - запросы распределяются между множеством узлов.
- Сжатие данных для экономии хранилища.
- Оплата за использование - нет необходимости в больших первоначальных инвестициях.

### Когда использовать Amazon Redshift

Когда _следует использовать_ Amazon Redshift:

- Для аналитики больших объемов данных (от терабайт до петабайт).
- Когда требуется сложный SQL-анализ и агрегация данных.
- Для интеграции с BI инструментами (Tableau, Looker, Power BI и т.д.).
- Когда нужно объединить данные из разных источников (RDS, S3, DynamoDB и т.д.) для комплексного анализа.
- Для построения отчетов и дашбордов в реальном времени.

Когда _НЕ следует_ использовать Amazon Redshift:

- Для транзакционных систем с высокой частотой операций записи.
- Когда требуется низкая задержка на уровне миллисекунд для отдельных запросов.
- Для небольших наборов данных, которые можно эффективно обрабатывать в реляционной базе данных.

> Redshift не подходит для операционных баз данных с частыми небольшими транзакциями. Используйте его для аналитики и отчетности, а RDS или DynamoDB для операционных данных.

## Практическая часть. Создание и подключение к RDS инстансу

Для создания RDS инстанса, выполните следующие шаги:

1. Войдите в AWS Management Console.
2. Создайте сеть VPC с двумя подсетями.
3. Перейдите в сервис Amazon RDS.
4. В левом меню выберите "Subnet groups" (1), после чего нажмите "Create DB Subnet Group".

   ![Рисунок 7. Выбор пункта Subnet Group](../_images/07/07_db_create_1.png)

   _Рисунок 7. Выбор пункта Subnet Groups_

5. Создайте Subnet Group, указав:

   1. Имя группы (Name) (2)
   2. Описание (Description) (3)
   3. Выберите VPC (4) - ту сеть, в которой созданы подсети, и в дальнейшем будет размещен RDS инстанс.
   4. Добавьте availability zones, в которых вы создали подсети (5).
   5. Выберите две подсети (6). В данных подсетях будут размещены основной и резервный инстансы RDS.

   _В контексте Free Tier, вы не сможете создать Multi-AZ развертывание, так как это ограничено. В примере выше показано создание Subnet Group для Multi-AZ, чтобы продемонстрировать процесс._
  
6. 

## Резюме

- _Различие между хранилищем данных и базой данных_. Хранилище предназначено для долгосрочного хранения файлов, база данных - для структурированного доступа к данным с возможностью сложных запросов.
- _Типы баз данных_. Реляционные базы данных (SQL) используют таблицы с фиксированной схемой и вертикальное масштабирование. NoSQL базы данных предлагают гибкую схему и горизонтальное масштабирование.
- _Продвинутые концепты_. Репликация создает копии данных для высокой доступности. Шардирование распределяет данные между серверами для масштабирования. Read replicas разгружают основную базу от операций чтения.
- _Amazon RDS - управляемый сервис для реляционных баз данных_. Автоматизирует бэкапы, патчинг, репликацию. Поддерживает MySQL, PostgreSQL, MariaDB, Oracle, SQL Server, Aurora, IBM Db2. Multi-AZ развертывание обеспечивает высокую доступность. Read replicas масштабируют операции чтения.
- _Amazon Aurora - это оптимизированный движок RDS с высокой производительностью_. До 5x быстрее MySQL и 3x быстрее PostgreSQL. Fully managed с автоматическим патчингом, бэкапами и масштабированием. Instant crash recovery и до 15 read replicas.
- _Amazon DynamoDB - управляемая NoSQL база данных_. Key-value и документная модель данных. Автоматическое горизонтальное масштабирование. Partition key определяет распределение данных, Sort key используется для сортировки и запросов диапазонов. Query эффективнее Scan для получения данных. TTL автоматически удаляет устаревшие данные.
- _Amazon Redshift - сервис хранилища данных для аналитики_. Колоночное хранение и массивно-параллельная обработка. Используется для enterprise data warehousing, big data analytics, machine learning.
- _Выбор правильного сервиса зависит от требований приложения_. RDS для транзакционных реляционных данных. DynamoDB для масштабируемых приложений с простыми запросами. Redshift для аналитики больших данных.

[^1]: _What’s the Difference Between Relational and Non-relational Databases?_. aws.amazon.com [online]. Available at: https://aws.amazon.com/compare/the-difference-between-relational-and-non-relational-databases/
[^2]: _Шардирование PostgreSQL: архитектура, алгоритмы и практические подходы_.
[^3]: _Amazon Relational Database Service_. aws.amazon.com [online]. Available at: https://aws.amazon.com/rds/
[^4]: _Amazon RDS vs. Amazon DynamoDB: Everything You Need to Know_. missioncloud.com [online]. Available at: https://www.missioncloud.com/blog/amazon-rds-vs-amazon-dynamodb-everything-you-need-to-know
[^5]: _Multi-AZ DB instance deployments for Amazon RDS_. docs.aws.amazon.com [online]. Available at: https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/Concepts.MultiAZSingleStandby.html
[^6]: _Amazon RDS Read Replicas_. aws.amazon.com [online]. Available at: https://aws.amazon.com/rds/features/read-replicas/
[^7]: _Amazon Aurora vs. RDS: Understanding the Difference_. tigerdata.com [online]. Available at: https://www.tigerdata.com/blog/amazon-aurora-vs-rds-understanding-the-difference
[^8]: _Amazon DynamoDB_. aws.amazon.com [online]. Available at: https://aws.amazon.com/ru/dynamodb/
